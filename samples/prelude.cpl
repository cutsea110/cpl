right object 1 with ! is
end object;

right object prod(a,b) with pair is
  pi1: prod -> a
  pi2: prod -> b
end object;

let dup  = pair(I,I);
# (a, b) -> (b, a)
let swap = pair(pi2, pi1);
# (a, (b, c)) -> ((a, b), c)
let assocl = pair(pair(pi1,pi1.pi2).pair(pi1,pi2),pi2.pi2);
# ((a, b), c) -> (a, (b, c))
let assocr = pair(pi1.pi1,pair(pi2.pi1,pi2).pair(pi1,pi2));
# (a, (b, c)) -> ((a, b), (a, c))
let distl = pair(pair(pi1,pi1.pi2),pair(pi1,pi2.pi2));
# ((a, b), c) -> ((a, c), (b, c))
let distr = pair(pair(pi1.pi1,pi2),pair(pi2.pi1,pi2));

# a^b x b -> a
right object exp(a,b) with curry is
  ev: prod(exp,b) -> a
end object;

let K  = curry(pi1);
# another style of K combinator
let K'(c) = c.!;
let KI = curry(pi2);
# another style of KI combinator
let KI'(_) = I;
let B  = curry(ev.pair(pi1,ev.pi2).assocr);
# another style of B combinator
let B'(f,g) = ev.pair(f.!,ev.pair(g.!,I));
let S  = curry(ev.pair(ev.pi1,ev.pi2).distr);
# another style of S combinator
let S'(f,g) = ev.pair(ev.pair(f.!,I),ev.pair(g.!,I));

left object bool with if is
  false: 1 -> bool
  true: 1 -> bool
end object;

left object option(a) with maybe is
  none: 1 -> option
  some: a -> option
end object;

left object both(a,b) with either is
  left: a -> both
  right: b -> both
end object;

left object nat with prn is
  0: 1 -> nat
  s: nat -> nat
end object;

let add  = ev.prod(prn(curry(pi2),curry(s.ev)),I);
# curried version (1 is supplied as pi1)
let cadd = curry(curry(add).pi2).1;
let mul = ev.prod(prn(curry(0.!),curry(add.pair(ev,pi2))),I);
# curried version (1 is supplied as pi1)
let cmul = curry(curry(mul).pi2).1;
let fact  = pi1.prn(pair(s.0,0),pair(mul.pair(s.pi2,pi1),s.pi2));

# list
left object list(a) with prl is
  nil: 1 -> list
  cons: prod(a, list) -> list
end object;

let hd = prl(none, some.pi1);
let tl = pi1.prl(pair(none,some.nil),pair(pi2.pi2,some.cons.pair(pi1,maybe(nil,I).pi2.pi2)));
let mapl(f) = prl(nil,cons.pair(ev.pair(f.!,pi1),pi2));
let lenl = prl(0.!,s.pi2);
let appendl = ev.prod(prl(curry(pi2),curry(cons.pair(pi1.pi1,ev.pair(pi2.pi1,pi2)))),I);
let suml = prl(0, add.pair(pi1,pi2));

# non empty list
left object nel(a) with prnel is
  unit: a -> nel
  cons': prod(a, nel) -> nel
end object;

let hd' = prnel(I, pi1);
let tl' = either(none.!,some).pi1.prnel(pair(left,left).unit, pair(either(right,right).pi2.pi2, left.cons'.pair(pi1,either(I,I).pi2.pi2)));
let mapnel(f) = prnel(unit.ev.pair(f.!,I),cons'.pair(ev.pair(f.!,pi1),pi2));
let lennel = prnel(s.0.!,s.pi2);
let appendnel = ev.prod(prnel(curry(cons'.pair(pi1,pi2)),curry(cons'.pair(pi1.pi1,ev.pair(pi2.pi1,pi2)))),I);
let sumnel = prnel(I,add.pair(pi1,pi2));

#
# TEST
# ====
#
# K combinator
# ------------
# simp full ev.pair(K.0, s.s.0) => K 0 2 => 0
#
# K' combinator
# -------------
# simp full K'(0).s.s.0 => as same above
#
# KI combinator
# -------------
# simp full ev.pair(KI.0, s.s.0) => KI 0 2 => 2
#
# KI' combinator
# --------------
# simp full KI'(0).s.s.0 => as same above
#
# B combinator
# ------------
# let add3 = curry(add).s.s.s.0
# let mul2 = curry(mul).s.s.0
# simp full ev.pair(B.pair(add3,mul2),s.s.s.s.0) => B add3 mul2 4 => add3 (mul2 4) => 3 + 8 => 11
#
# B' combinator
# -------------
# simp full B'(add3,mul2).s.s.s.s.0 => as same above
#
#
# S combinator
# ------------
# let mul2 = curry(mul).s.s.0
# simp full ev.pair(S.pair(cadd, mul2), s.s.s.0) => s cadd mul2 3 => cadd 3 (mul2 3) => 3 + 6 => 9
#
# S' combinator
# -------------
# simp full S'(cadd,mul2).s.s.s.0 => as same above
#
# SKK = I
# -------
# let cK = curry(K.pi2).0
# simp ev.pair(S.pair(cK, K), s.s.s.0) => S K K 3 => I 3 => 3
#